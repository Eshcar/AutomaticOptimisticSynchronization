\section{\ldots}
%The main idea: 
We address the problem of introducing 
optimism to a pessimistic locking protocol. 
Given an implementation using a 
pessimistic locking protocol, performing load and store steps 
on locked objects only, we add optimistic synchronization. 
The idea of optimistic synchronization is to load 
shared variables without locks and start using the 
locking protocol only when the operation reaches a store step.
Our algorithm shows that it is redundant to 
acquire locks if they are freed before any change is made.    

This optimistic scheme separates the operation to three
\emph{phases}, an optimistic \emph{read phase},
a pessimistic \emph{read-write phase} and a 
\emph{validation phase} that connect them. 

\subsection{Detailed Algorithm}
Each object maintains a counter, incremented every time the 
object is locked. This counter is used to validate the correctness
of the optimistic read phase. 

\begin{description}
  \item[Read Phase] Stats at the beginning of the operation and
  ends at any point before the first store operation. 
  During this phase the operation maintains a \readSet, 
  containing references to objects loaded and the local 
  version when it was read. The local versions are incremented 
  during the read-write phase, when the object is locked. 
  Incrementing the version is not atomic with the lock, thus, 
  the object is also checked to be unlocked. 
  The read phase does not validate reads, 
  in order to avoid infinite loops, a timeout is set. 
  If the operation reaches the timeout, 
  a \readSet validation takes place, if it fails 
  the operation restarts from the beginning.
  The use of timeout does not guarantee that the 
  operation reads a consistent snapshot of the memory, 
  thus, \ldots 
  %A pseudo code of the transformation can be found in 
  %Figure \ref{figure:readPhaseTransformation}. 
  
  \item[Validation Phase] This phase connects the read phase
  with the read-write phase. It has two requirements: (i) lock 
  local variables of the operation and (ii) ensure that the 
  values read during the read phase are consistent, i.e.
  as if the values were read while executing the locking 
  protocol. To avoid deadlocks, the locks are acquired using 
  a \code{try\_lock} operation, if the \code{try\_lock} fails, 
  the operation restarts from the beginning. Next, the \readSet 
  is validated, if the validation fails the operation restarts from the
  beginning. During the \readSet validation, each reference saved 
  in the \readSet is checked to be unlocked and that the current 
  version matches the version saved in the \readSet. 
  %A pseudo code of the \readSet validation can be found in
  %Figure \ref{figure:readSetValidation}.
  
  \item[Read-Write Phase] This phase enforces the locking protocol
  while maintaining the local versions, i.e., the local version of 
  an object is incremented every time it is locked.  
  Once the read-write phase begins, the operation is guaranteed to to 
  finish without restarts.  
\end{description}

%The use of timeout does not guarantee
%\emph{opacity}~\cite{GuerraouiK2008} or 
%\emph{validity}\cite{LevAriCK2014}. 

%The \readSet validation first checks that the node is unlocked,
%(or locked by the current operation), then it checks that the 
%current version is equal to the version saved in the \readSet. 
 
%ALGORITHM CODE

\begin{figure*}
	\begin{center}
	\begin{subfigure}{.49\textwidth}
		\begin{algorithmic}[1]{}
			{\ttfamily
			\Function{foo}{Node new} \label{code:begin}
			
			\State prev = head
			\State succ = prev.next
			\State prev = succ
			\State succ = succ.next
			\State new.next = succ
			\State prev.next = new
			
			\EndFunction
			}
		\end{algorithmic}
	%\end{subfigure}
   % \begin{subfigure}{.3\textwidth}
   	\bigskip
		\begin{algorithmic}[1]{}
		{\ttfamily
			\Function{foo}{Node new} \label{code:begin}
			\State Node prev = head
			\State prve.lock()
			\State Node succ = prev.next
			\State succ.lock()
			\State prev.unlock()
			\State prev = succ
			\State succ = succ.next
			\State succ.lock()
			\State new.next = succ
			\State prev.next = new
			\State prev.unlock()
			\State succ.unlock()
			\EndFunction
			}
		\end{algorithmic}
	\end{subfigure}
	\begin{subfigure}{.49\textwidth}
		\begin{algorithmic}[1]{}
		{\ttfamily
			\Function{foo}{Node new} \label{code:begin}
			\State Node prev = head
			\State long version = prev.getVersion()
			\If{prev.isLocked()}
				\State \textbf{goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf
			\State readSet.add(prev,version) 
			\State Node succ = prev.next
			\If{succ.isLocked()}
				\State {\textbf goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf
			\State readSet.add(succ,version) 
			\State prev = succ
			\State succ = succ.next
			\If{succ.isLocked()}
				\State \textbf{goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf
			\State readSet.add(succ,version) 
			%\Statex
			\If{!prev.tryLock()} 		
				\State \textbf{goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf	
			\If{!succ.tryLock()} 		
				\State prev.unlock()
				\State \textbf{goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf	
			\If{!readSet.validate()} 		
				\State prev.unlock()
				\State succ.unlock()
				\State \textbf{goto} \ref{code:begin} 
				%\Comment Restart Operation
			\EndIf	
			%\Statex
			\State new.next = succ
			\State prev.next = new
			\State prev.unlock()
			\State succ.unlock()

			\EndFunction
			}
		\end{algorithmic}
	\end{subfigure}
	%\bigskip
	%\hline
	\end{center}
	\caption{
			\label{figure:transformation}}
\end{figure*}

%END CODE 