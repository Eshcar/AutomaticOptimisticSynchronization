\section{Automatic Transformation}\label{sec:algorithm}

% What we do
Our goal is to automatically transform a given (lock-free) implementation of a sequential data structure to a correct and efficient concurrent one.
We achieve efficiency by carefully introducing a combination of pessimistic and optimistic concurrency control mechanisms into the code. The former are 
added by a given black-box code transformation that ensures some locking protocol. Our algorithm then replaces a subset of the pessimistic
steps with optimistic ones. This section first overviews our general approach to combining optimism and pessimism (Section~\ref{ssec:overview}), and
then delves into the details of our code transformation, illustrated by an example (Section~\ref{ssec:transformation}).

\subsection{Combining Optimism and Pessimism}\label{ssec:overview}

% Optimism
Generally speaking, optimistic concurrency control is a form of lock-free synchronization, which accesses shared variables without locks in the hope that they will not be modified by others before the end of the operation (or more generally, the transaction). To verify the latter, optimistic concurrency control relies on \emph{validation}, which is typically implemented using version numbers. If validation fails, the operation restarts. Optimistic execution of update operations requires either performing roll-back (reverting variables to their old values) upon validation failure, or deferring writes to commit time; both approach induce significant overhead \Idit{citation supporting this?}. 


%The main idea: 
The main idea behind our protocol is judicious use of optimistic synchronization to read 
shared variables without locks as long as no updates occur. Once an operation performs a store step, 
we start using the pessimistic (lock-based) protocol. In other words, we rely on validation at the end of the 
read-only prefix of an operation in order to render redundant all locks that would have been freed
before any change is made.
This scheme is particularly suitable for data structure implementations,
since the common behavior of their operations 
is to first traverse the data structure, and then 
perform (mostly local) modifications at the end of the operation.


Conceptually, our approach divides an operation into three phases: an optimistic \emph{read-only phase},
a pessimistic \emph{update phase} and a \emph{validation phase} that conjoins them. 
The read-only phase traverses the data structure without taking any locks, while maintaining sufficient information to later ensure the correctness of the traversal.
The update phase executes the original locking protocol. 
The validation phase bridges between the optimistic and pessimistic ones.
It first locks the objects required by
the locking protocol and then validates the correctness
of the of the read-only phase, allowing the 
update phase to run as if the an execution of the locking
protocol took place. If the validation fails, the operation 
restarts. In order to avoid livelock, we set a threshold on the number of restarts.
If the threshold is exceeded, the code falls back on pessimistic execution. 

\subsection{Transformation Details}\label{ssec:transformation}
To illustrate our transformation a simple code example is 
provided in Figure \ref{figure:transformation} 
with auxiliary functions in Figures \ref{figure::track} and 
\ref{figure::validate}.

We start our transformation by applying three preparation steps
to the given sequential algorithm.
First, we use the ``black box'' transformation to produce an
algorithm that ensures the locking protocol 
(Figure \ref{figure:transformation:before}). 
Second, we add version numbers to shared memory objects, 
incremented every time the object is locked. 
These version numbers are used 
to validate the correctness of the read-only phase during 
the validation phase as well as at timeouts and exceptions.
Lastly, we identify the read only prefix of each operation. 

Next we explain what the transformation does in each phase (Figure
\ref{figure:transformation:after}). 

\paragraph{Read-only Phase} 
  During this phase the operation maintains a \emph{locked set}
  and a \emph{read set}. 
  The locked set is used to track the lock and unlock steps
  of the locking protocol, thus, we replace each lock step 
  with a step adding the object to the locked set 
  (line \ref{code:lockedSet:add} of auxiliary function 
  track, Figure \ref{figure::track}). 
  and each unlock step with a step removing the object 
  from the locked set (line \ref{code:lockedSet:remove}). 
  (Since the locking protocol might allow re-entrant locks, 
  our locked set allows duplications and the remove 
  operation removes one of the duplications of the object).
  
The read set is used to track all objects accessed by the 
operation in order to later validate that this read set
belongs to a consistent view of shared memory.  
It contains a mapping between references to objects loaded 
to the local version at the time it was read. After 
objects are added to the read set they are checked to be 
unlocked, if the object is locked the operation restarts
from the beginning (lines
\ref{code:track:getVersion}-\ref{code:track:returnFalse} of auxiliary function
track, Figure \ref{figure::track}).

%Object are added to the read set immediately 
%after they are added to the locked set.  

%Incrementing the local version of an object is not 
%done atomically with the lock acquisition, thus, 
%the object is also checked to be unlocked, if it is locked
%the operation restarts from the beginning. 
%This also ensures that the operation never reads old values 
%with a new version. 
 
The read phase does not validate reads during its traversal, 
in order to avoid infinite loops, a timeout is set. 
If the operation reaches the timeout, a read set 
validation takes place (described in the validation phase), 
if it fails the operation restarts from the beginning.
  
  %The use of timeout does not guarantee that the 
  %operation reads a consistent snapshot of the memory, 
  %thus, \ldots 
  %A pseudo code of the transformation can be found in 
  %Figure \ref{figure:readPhaseTransformation}. 

\paragraph{Validation Phase} 
The validation phase is inserted to the code after
the read-only phase (lines
\ref{code:validateLockedSet}-\ref{code:validateGoto2}). 
It locks the objects in the locked set and validates the read set. 

To avoid deadlocks, the locks are acquired using a tryLock
operation, if the tryLock fails, the operation unlocks 
previously acquired locks and restarts from the beginning 
(lines \ref{code:validateLockedSet}-\ref{code:validateGoto1}). 
The calls to tryLock also increment the versions 
of the object,  these objects are also part of the 
operations read set. 
To avoid the operation invalidating itself, 
a successful tryLock operation is followed by incrementing
the version saved in the read set.  

The read set validation is performed as follows, 
each object saved in the read set is checked to be unlocked 
and that the current version matches the version saved in the 
read set (Figure \ref{figure::validate}). If this check fails, the operation releases all its
locks and restarts from the beginning
(lines \ref{code:validateReadSet}-\ref{code:validateGoto2}). 
This guarantees
that the object was not locked from the time it was read until
the time it was validated, since all operations write only to
locked nodes it follows that the object was not changed.  
The read set validation can be viewed as a double collect 
to all objects accessed by the read-only phase. 

%The order between checking the version and checking that the object is unlocked
%is important, as locking and incrementing versions is not atomic. 

%A pseudo code of the \readSet validation can be found in
%Figure \ref{figure:readSetValidation}.
  
\paragraph{Update Phase} 
This phase enforces the locking protocol
  while maintaining the local versions, i.e., the local version of 
  an object is incremented every time it is locked.  
  Once the update phase begins, the operation is guaranteed to to 
  finish without restarts.  


 

\Xomit{  
\subsection{Transformation Details}
We invoke the following steps to a code that implements 
fine grained locking and follows a correct locking
protocol.  

\begin{enumerate}
  \item Add version numbers to shared memory objects, 
  incremented every time the object is locked. These 
  version numbers are used to validate the correctness
  of the optimistic read phase during the validation phase
  as well as timeouts and exceptions.
  
  \item Identify the read only prefix of each data structure 
  operation. In the beginning of the read phase allocate 
  and initialize local \emph{read set} and \emph{timeout}
  objects. The read set object is a storage object used to save 
  references to objects along with version numbers. 
  The timeout object tracks the progress of the operation\ldots 
    
  \item Transform the read only prefix to optimistic traversal 
   by replacing lock steps \ldots 
   Incrementing the version is not atomic with the lock, thus, 
   the object is also checked to be unlocked. 

\end{enumerate}
}
%The use of timeout does not guarantee
%\emph{opacity}~\cite{GuerraouiK2008} or 
%\emph{validity}\cite{LevAriCK2014}. 

%The \readSet validation first checks that the node is unlocked,
%(or locked by the current operation), then it checks that the 
%current version is equal to the version saved in the \readSet. 
 
%ALGORITHM CODE
\renewcommand{\ttdefault}{pcr}
%\algrenewcommand\textkeyword{\texttt}
\algrenewcommand\algorithmicif{\texttt{if}}
\algrenewcommand\algorithmicthen{\texttt{then}}
\algrenewcommand\algorithmicfunction{\textsc{Function}}
\algrenewcommand\algorithmicforall{\texttt{for all}}
\algrenewcommand\algorithmicdo{\texttt{do}}
\algrenewcommand\textproc{\textit}

\begin{figure*}
	\begin{center}
	\begin{subfigure}{.49\textwidth}
		\begin{algorithmic}[1]{}
		{\ttfamily
			\Function{addThird}{Node new} \label{code:begin}
			\Statex ----------------------------
			\State \textbf{Node prev = head} 
			\State prev.lock()
			\State 
			\State \textbf{Node succ = prev.next}
			\State succ.lock()
			\State
			\State prev.unlock()
			\State \textbf{prev = succ}
			\State \textbf{succ = succ.next}
			\State succ.lock()
			\State
			\Statex ----------------------------
			\State
			\State
			\State
			\State
			\State
			\State
			\Statex ----------------------------
			\State \textbf{prev.next = new}
			\State \textbf{new.next = succ}
			\State prev.unlock()
			\State succ.unlock()
			\EndFunction
			}
		\end{algorithmic}
		\caption{ Code synthesized with hand over
		hand locking protocol} \label{figure:transformation:before} 
	\end{subfigure}
	\begin{subfigure}{.49\textwidth}
		\begin{algorithmic}[1]{}
		{\ttfamily
			\Function{addThird}{Node new} \label{code:begin}
			\Statex ----------------------------
			\Comment{\textrm{read-only phase}}
			\State \textbf{Node prev = head}
			\If{!track(prev)}
				\State {goto} \ref{code:begin} \label{code:readGhaseGoto1}
				%\Comment Restart Operation
			\EndIf
			\State \textbf{Node succ = prev.next}
			\If{!track(succ)}
				\State {goto} \ref{code:begin}  \label{code:readGhaseGoto2}
				%\Comment Restart Operation
			\EndIf		
			\State lockedSet.remove(prev) \label{code:lockedSet:remove}
			\State \textbf{prev = succ}
			\State \textbf{succ = succ.next}
			\If{!track(succ)}
				\State {goto} \ref{code:begin} \label{code:readGhaseGoto3}
				%\Comment Restart Operation
			\EndIf
			\Statex ----------------------------
			\Comment{\textrm{validation phase}}
			\If{!lockedSet.tryLockAll()} 	\label{code:validateLockedSet}	
				\State releaseAll()
				\State {goto} \ref{code:begin} \label{code:validateGoto1}
				%\Comment Restart Operation
			\EndIf	
			\If{!readSet.validate()} 		\label{code:validateReadSet}
				\State releaseAll()
				\State {goto} \ref{code:begin} \label{code:validateGoto2}
				%\Comment Restart Operation
			\EndIf	
			\Statex ----------------------------
			\Comment{\textrm{update phase}}
			\State \textbf{prev.next = new}
			\State \textbf{new.next = succ}			
			\State prev.unlock()
			\State succ.unlock()

			\EndFunction
			}
		\end{algorithmic}
		\caption{ Code synthesized with our
		automatic transformation}\label{figure:transformation:after}
	\end{subfigure}
	%\bigskip
	%\hline
	\end{center}
	\caption{Code example. 
	The original sequential code
	is in bold.
			\label{figure:transformation}}
\end{figure*}

\begin{figure}
\begin{algorithmic}[1]{}
		{\ttfamily
		\Function{track}{Node node}
		\State lockedSet.add(node) \label{code:lockedSet:add}
			\State long version = node.getVersion() \label{code:track:getVersion}
			\State readSet.add(node,version)  
			\If{node.isLocked()}
				\State return false \label{code:track:returnFalse}
				%\Comment Restart Operation
			\EndIf
			\State retrun true
		\EndFunction
		}
\end{algorithmic}
\caption{ In read-only phase, locking is replaced by 
tracking locks and read
objects' versions.
\label{figure::track}}
\end{figure}

\begin{figure}
\begin{algorithmic}[1]{}
		{\ttfamily
		\Function{validate}{}()
		\ForAll {Node node in readSet}
			\If{node.isLocked()}
				\State return false
			\EndIf
			\State long version = readSet.getVersion(node)
			\If{node.getVersion() != version}
				\State return false
			\EndIf
		\EndFor
		\State retrun true
		\EndFunction
		}
\end{algorithmic}
\caption{Read set validation.\label{figure::validate}}
\end{figure}


%END CODE 