\section{Preliminaries}
%A \emph{concurrent system} (module) consists of a set of threads, 
\subsection{Shared Memory Model}
A \emph{module} defines a set of \emph{abstract data types} and a 
set of \emph{operations} that may be invoked by
clients of the module.
Each operation is invoked with possible parameters
and returns with a response. 
The invocation is a local step of a thread, 
followed by a execution of a sequence of atomic steps. 
Atomic step is either a computation on local 
variables or a primitive operation on shared variable.
Read and write to shared memory are 
denoted load and store.  
%a load (``\code{x=y.f}'') or 
%a store (``\code{x.f=y}'') operation on shared variables.
The parameters and local variables 
of an operation are private to the
invocation of the operation (thread local). 
There are no static or global variables shared by  
different invocations of the operations. 

A \emph{configuration} is an instantaneous representation 
of the system, including the state of the shared memory
and the local variables. In the \emph{initial configuration} 
all variables hold an initial value. 
An \emph{execution} is an alternating sequence of 
configurations and steps,
$C_0,s_1,\ldots,s_i,C_i,\ldots,$ 
where $C_0$ is the initial configuration,
and each configuration $C_i$ is the result of
executing step $s_i$ on configuration $C_{i-1}$.
 
An execution is \emph{non-interleaved} 
(abbreviated NI-execution) if primitive operation of 
different operations are not interleaved, i.e., 
for every pair of operations invocations $p_i \neq p_j$ 
either all primitive operations of $p_i$ come before any 
primitive operation of $p_j$, or vice versa.

\subsection{Locking Protocols}
Get some text-book definitions of locking protocols. 

In order for our algorithm to work, the initial locking
protocol must have one of the following properties: 

\begin{itemize}
\item The protocols allows early lock release. 
\item The protocols requires that all locks are acquired 
before the first store step.    
\end{itemize}


\subsection{Correctness Conditions}
Given an execution, we say that two primitive operations 
\emph{conflict} if (i) they are executed by two different threads, 
(ii) they access some common global variable or a heap allocated object 
(iii) at least one of the conflicting instruction is a write.


%Let $\pi$ be an execution and $op_i,op_j$ are primitive operations in $\pi$ the
% conflict relation of $\pi$ is: \\ $conf(\pi)=\{(op_i,op_j)\mid op_i$ and $op_j$ are in conflict and $op_i<_{\pi}op_j\}$\\

%Let $\pi$ be an execution the conflict graph $G(\pi)=(V,E)$ is defined by:\\ $V
% = \{$ all operations (threads) of $\pi\}$\\
%$E = \{ (t_i,t_j) \mid t_i\neq t_j$ and $\exists op_i\in t_i, \exists op_j\in
% t_j$ such that $(op_i,op_j)\in conf(\pi) \}$\\

Executions $\pi_1$ and $\pi_2$ are \emph{conflict-equivalent} 
if they include the same primitive operations and they 
agree on the order between conflicting operations. 
An execution is \emph{conflict-serializable} if it is 
conflict-equivalent with a non-interleaved execution.

%DOMINATION LOCKING
%\emph{Domination Locking Protocol} is a conflict serializable
%locking protocol presented in \cite{Gueta2011}. 
%It requires a fixed total order $\leq$ on all heap objects. 
%An execution satisfies the the Domination Locking protocol,
%with respect to $\leq$ if it satisfies the following conditions:
