%%This is a very basic article template.
%%There is just one section and two subsections.

\title{Scalable Automatic Synchronization Combining Optimism with Pessimism}
\documentclass{article}
\usepackage{xspace}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}

%-------------Theorem Definitions ---------------%
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\qedsymb\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}
\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}

%--------------------------------------------------%

\newcommand{\code}[1]{\textsf{#1}}
\newcommand{\readV}{\code{read\_version}\xspace} 
\newcommand{\readSet}{\code{read\_set}\xspace}
\newcommand{\writeV}{\code{write\_version}\xspace}

\newcommand{\reqI}{\textbf{LPR1}\xspace}
\newcommand{\reqII}{\textbf{LPR2}\xspace}

\begin{document}
\maketitle

\abstract{We present an \emph{automatic} approach for 
parallelizing sequential data structures in a way that 
is both safe and scalable. While there exist pessimistic 
transformations that make code thread-safe by adding 
(either global or fine-grained) locks, this approach is 
limited in its performance due to synchronization bottlenecks, 
for example, locking the root in a tree data structure. 
In this paper, we improve the performance and scalability 
of such synthesized code by reducing bottlenecks. 
Specifically, we present an automatic approach to eliminate 
many of the locking steps, relying instead on optimistic 
partial traversals of the data structure. 
We realize our approach for tree data structures, 
using the domination locking technique. 
The resulting code scales well, 
significantly outperforms pessimistic approaches, 
and achieves performance close to those of 
custom-tailored concurrent data structures. 
Our work thus shows the promise that automated approaches 
bear for overcoming the difficulty involved in manually 
hand crafting concurrent data structures. 
}
\input{introduction}
\input{preliminaries}
\input{algorithm}
\input{proof}
\input{evaluation}
\input{related}
 
\bibliography{myRef}
\bibliographystyle{plain}
\end{document}
